{
  "name": "Stigmi",
  "nodes": [
    {
      "parameters": {
        "public": true,
        "initialMessages": "Hi there! \ud83d\udc4b\n\nMy name is Nathan. Ready to learn math?\nHere's your first problem:\nWhat is -3 + 5?",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chatTrigger",
      "typeVersion": 1.1,
      "position": [
        -1600,
        -720
      ],
      "id": "9a37e68d-f19b-4650-99a4-801e426a4f8e",
      "name": "When chat message received",
      "webhookId": "d6075ce6-263d-4b56-82b1-de4f2f013f73"
    },
    {
      "parameters": {
        "options": {
          "maxTokens": 500,
          "temperature": 0.2
        }
      },
      "id": "be5014dc-4bc3-41d3-b724-4978415ca4f4",
      "name": "OpenAI Chat Model",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1,
      "position": [
        176,
        -464
      ],
      "credentials": {
        "openAiApi": {
          "id": "IsfTAJGtC8cYJaRq",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Format verification result for Build Response Context\nconst inputData = $input.first();\nconst verificationResult = inputData.json.verification_result;\n\n// Map teach_back_explanation to stuck for routing (same as Parse Agent Output does for scaffolding)\nlet category = verificationResult.category;\nif (category === 'teach_back_explanation') {\n  category = 'stuck';\n}\n\nreturn {\n  json: {\n    category: category,\n    confidence: verificationResult.confidence,\n    is_main_problem_attempt: verificationResult.is_main_problem_attempt,\n    verification: null,\n    agent_reasoning: verificationResult.reasoning,\n    tool_used: 'llm_classify_verify',\n    original_category: verificationResult.category\n  }\n};"
      },
      "id": "3c1a25a3-9d3b-43da-a810-c4943bd2142c",
      "name": "Format for Routing",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        288,
        0
      ],
      "notes": "Formats verification result to match Build Response Context expectations"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict"
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.is_scaffolding_active }}",
                    "rightValue": true,
                    "operator": {
                      "type": "boolean",
                      "operation": "true"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "scaffolding_active"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "id": "fdb359d7-5321-4aa9-8a06-8a4dea5c8438",
      "name": "Switch: Scaffolding Active?",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [
        -32,
        -592
      ],
      "notes": "Routes to AI Agent only if scaffolding is active"
    },
    {
      "parameters": {
        "jsCode": "// Parse LLM extraction and merge with code verification\nconst llmData = $('Code: Verify Answer').first().json;\nconst contextData = $('Prepare Agent Context').first().json;\n\nreturn {\n  json: {\n    student_message: contextData.student_message,\n    current_problem: contextData.current_problem,\n    attempt_count: contextData.attempt_count,\n    is_scaffolding_active: contextData.is_scaffolding_active,\n    scaffolding_depth: contextData.scaffolding_depth,\n    scaffolding_last_question: contextData.scaffolding_last_question,\n    is_teach_back_active: contextData.is_teach_back_active,\n    teach_back_awaiting: contextData.teach_back_awaiting,\n    last_tutor_question: contextData.last_tutor_question,\n    last_category: contextData.last_category,\n    session_id: contextData.session_id,\n    student_id: contextData.student_id,\n    _session: contextData._session,\n    _start_time: contextData._start_time,\n    verification_result: {\n      category: llmData.final_category,\n      is_main_problem_attempt: llmData.is_main_problem_attempt,\n      confidence: llmData.confidence,\n      reasoning: llmData.reasoning\n    }\n  }\n};"
      },
      "id": "2b94a676-7f74-4887-bfa7-4cc4e4db39c8",
      "name": "Parse Classification",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -208,
        -592
      ],
      "notes": "Merges LLM extraction with code verification results"
    },
    {
      "parameters": {
        "jsCode": "// Code-based answer verification (Stage 2)\nconst inputData = $input.first();\nconst llmResponse = inputData.json.message?.content || inputData.json.text || '';\nconst contextData = $('Prepare Agent Context').first().json;\n\nlet llmExtraction;\ntry {\n  llmExtraction = JSON.parse(llmResponse);\n  \n  if (!llmExtraction.category) {\n    throw new Error('Missing category field');\n  }\n} catch (error) {\n  // Fallback if JSON parsing fails\n  llmExtraction = {\n    is_answer: false,\n    category: 'stuck',\n    extracted_value: null,\n    confidence: 0.5,\n    reasoning: `Parse error: ${error.message}`\n  };\n}\n\n// If not an answer attempt, pass through unchanged\nif (!llmExtraction.is_answer) {\n  return {\n    json: {\n      final_category: llmExtraction.category,\n      is_main_problem_attempt: false,\n      confidence: llmExtraction.confidence,\n      reasoning: llmExtraction.reasoning,\n      extracted_value: null\n    }\n  };\n}\n\n// Answer attempt - verify numerically\nconst studentValue = llmExtraction.extracted_value;\nconst correctAnswer = contextData.current_problem.correct_answer;\n\n// Parse correct answer\nlet correctValue;\ntry {\n  correctValue = parseFloat(String(correctAnswer).replace(/[^0-9.\\-]/g, ''));\n  if (isNaN(correctValue)) {\n    throw new Error('Cannot parse correct answer');\n  }\n} catch (error) {\n  // Cannot verify - treat as stuck\n  return {\n    json: {\n      final_category: 'stuck',\n      is_main_problem_attempt: false,\n      confidence: 0.5,\n      reasoning: `Verification error: ${error.message}`,\n      extracted_value: studentValue\n    }\n  };\n}\n\n// Check if extracted value is valid\nif (studentValue === null || isNaN(studentValue)) {\n  return {\n    json: {\n      final_category: 'stuck',\n      is_main_problem_attempt: false,\n      confidence: llmExtraction.confidence,\n      reasoning: 'Could not extract numeric value from student response',\n      extracted_value: null\n    }\n  };\n}\n\n// Numeric comparison\nconst diff = Math.abs(studentValue - correctValue);\nconst percentThreshold = Math.abs(correctValue * 0.2); // 20%\nconst closeThreshold = Math.max(percentThreshold, 0.3); // At least 0.3\n\nconst isCorrect = diff < 0.001;\nconst isClose = !isCorrect && diff <= closeThreshold;\n\nlet finalCategory;\nif (isCorrect) {\n  finalCategory = 'correct';\n} else if (isClose) {\n  finalCategory = 'close';\n} else {\n  finalCategory = 'wrong_operation';\n}\n\nreturn {\n  json: {\n    final_category: finalCategory,\n    is_main_problem_attempt: true,\n    confidence: llmExtraction.confidence,\n    reasoning: `Extracted ${studentValue}, correct is ${correctValue}, diff ${diff.toFixed(2)}`,\n    extracted_value: studentValue,\n    correct_value: correctValue,\n    difference: diff\n  }\n};"
      },
      "id": "d381b364-a0c7-419f-a9e1-71b965343152",
      "name": "Code: Verify Answer",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -368,
        -592
      ],
      "notes": "Verifies numeric answers with 20% threshold logic"
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "messages": {
          "values": [
            {
              "content": "=You are a math tutoring intent classifier and value extractor.\n\nProblem: {{ $json.current_problem.text }}\nStudent's Message: \"{{ $json.student_message }}\"\n\nContext:\n- Scaffolding Active: {{ $json.is_scaffolding_active }}\n- Teach-Back Active: {{ $json.is_teach_back_active }}\n\nYour job: Determine intent and extract numeric values.\n\n**CRITICAL EXTRACTION RULE**:\nExtract EXACTLY what the student SAID, NOT what you think they MEANT.\n- If student says \"one\", extract 1 (even if the correct answer is 2)\n- If student says \"eight\", extract 8 (even if the correct answer is 2)\n- DO NOT \"correct\" the student's answer - extract their stated value literally\n- Your job is extraction, NOT evaluation of correctness\n\n**TEACH-BACK SCENARIO**: If teach_back_active = true\nStudent is explaining their reasoning after getting the answer correct.\nEven if explanation is weak, vague, or just \"I followed your lead\", \"you helped me\", \"I guessed\", this is STILL a teach-back explanation.\nReturn: {\"is_answer\": false, \"category\": \"teach_back_explanation\", \"extracted_value\": null}\n\nEXAMPLES of teach-back explanations:\n- \"I just followed your lead\" \u2192 teach_back_explanation\n- \"You helped me figure it out\" \u2192 teach_back_explanation\n- \"I added them together\" \u2192 teach_back_explanation\n- \"I don't know how I got it\" \u2192 teach_back_explanation\n- \"I guessed\" \u2192 teach_back_explanation\n\n**ANSWER ATTEMPT**: Does the message contain a numeric answer?\n- Look for numbers: digits (\"1\", \"2\"), written (\"one\", \"two\"), expressions (\"1/2\", \"0.5\")\n- Include approximations: \"around 2\", \"about two\", \"maybe 1\"\n- \"I think it's one\" = answer attempt \u2713\n- \"I don't know what one means\" = NOT an answer \u2717\n\nIf YES (answer attempt):\n1. Extract the numeric value (convert written numbers to digits)\n2. Return: {\"is_answer\": true, \"category\": \"answer\", \"extracted_value\": <number>}\n\n**NON-ANSWER**: If not an answer attempt:\n- CONCEPTUAL_QUESTION: Asking about concepts (\"what is\", \"why\", \"how does\")\n- STUCK: Indicating confusion/need help (\"don't know\", \"help\", \"stuck\")\n- OFF_TOPIC: Unrelated to math\n\nReturn: {\"is_answer\": false, \"category\": \"conceptual_question|stuck|off_topic\", \"extracted_value\": null}\n\nOUTPUT FORMAT (JSON only):\n{\n  \"is_answer\": true/false,\n  \"category\": \"answer|conceptual_question|stuck|off_topic|teach_back_explanation\",\n  \"extracted_value\": <number or null>,\n  \"confidence\": 0.0-1.0,\n  \"reasoning\": \"brief explanation\"\n}\n\nEXAMPLES:\n\nStudent: \"one\" (Problem: \"What is -3 + 5?\")\n\u2192 {\"is_answer\": true, \"category\": \"answer\", \"extracted_value\": 1, \"confidence\": 0.95, \"reasoning\": \"Extracted 1 from student's literal answer 'one'\"}\n\nStudent: \"eight\" (Problem: \"What is -3 + 5?\")\n\u2192 {\"is_answer\": true, \"category\": \"answer\", \"extracted_value\": 8, \"confidence\": 0.95, \"reasoning\": \"Extracted 8 from student's literal answer 'eight'\"}\n\nStudent: \"I think it's around two\"\n\u2192 {\"is_answer\": true, \"category\": \"answer\", \"extracted_value\": 2, \"confidence\": 0.9, \"reasoning\": \"Approximate answer, extracted value 2\"}\n\nStudent: \"What does negative mean?\"\n\u2192 {\"is_answer\": false, \"category\": \"conceptual_question\", \"extracted_value\": null, \"confidence\": 0.95, \"reasoning\": \"Asking about concept\"}\n\nStudent: \"I don't know\"\n\u2192 {\"is_answer\": false, \"category\": \"stuck\", \"extracted_value\": null, \"confidence\": 0.9, \"reasoning\": \"Indicating need for help\"}\n\nYour response (JSON only):"
            }
          ]
        },
        "options": {
          "maxTokens": 150,
          "temperature": 0.2
        }
      },
      "id": "ade8abb8-b434-43cc-9d2d-51eb8c9f9a6f",
      "name": "LLM: Extract Intent & Value",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.4,
      "position": [
        -720,
        -592
      ],
      "credentials": {
        "openAiApi": {
          "id": "IsfTAJGtC8cYJaRq",
          "name": "OpenAi account"
        }
      },
      "notes": "LLM extracts intent and numeric values from student input"
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $json.session_id }}_problem_{{ $json.current_problem.id }}",
        "contextWindowLength": 15
      },
      "id": "b02d34be-4d5a-4201-8320-7c3e7597d573",
      "name": "Window Buffer Memory",
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.2,
      "position": [
        320,
        -464
      ],
      "notes": "Tracks last 15 turns per problem (auto-resets when problem ID changes)"
    },
    {
      "parameters": {
        "description": "Verifies if a student's numeric answer to the main math problem is correct, close (within 20%), or wrong. Parameters: student_message (string), correct_answer (string). Returns: 'correct', 'close', or 'wrong_operation'",
        "jsCode": "// Verify Main Answer - Read from workflow context ($json)\ntry {\n  // Extract data from workflow context (passed by Prepare Agent Context node)\n  const studentMessage = $json.student_message || '';\n  const correctAnswer = $json.current_problem?.correct_answer || '';\n  \n  if (!studentMessage || !correctAnswer) {\n    return 'error: missing student_message or correct_answer in workflow context';\n  }\n  \n  const studentAnswer = String(studentMessage).toLowerCase().trim();\n  const correctAnswerStr = String(correctAnswer).toLowerCase().trim();\n  \n  // Extract just numbers (handle negative, decimals, fractions)\n  let studentNum = studentAnswer.replace(/[^0-9.\\-]/g, '');\n  let correctNum = correctAnswerStr.replace(/[^0-9.\\-]/g, '');\n  \n  if (!studentNum || !correctNum) {\n    return 'error: could not parse numbers';\n  }\n  \n  const studentVal = parseFloat(studentNum);\n  const correctVal = parseFloat(correctNum);\n  \n  if (isNaN(studentVal) || isNaN(correctVal)) {\n    return 'error: invalid numbers';\n  }\n  \n  // Calculate difference and thresholds\n  const diff = Math.abs(studentVal - correctVal);\n  const percentThreshold = Math.abs(correctVal * 0.2); // 20%\n  const closeThreshold = Math.max(percentThreshold, 0.3); // At least 0.3\n  \n  const isCorrect = diff < 0.001;\n  const isClose = !isCorrect && diff <= closeThreshold;\n  \n  // Return category as string (agent will parse this)\n  if (isCorrect) {\n    return 'correct';\n  } else if (isClose) {\n    return 'close';\n  } else {\n    return 'wrong_operation';\n  }\n  \n} catch (error) {\n  return 'error: ' + error.message + ' | stack: ' + error.stack;\n}"
      },
      "id": "674f1926-953e-4456-b1fd-985adfd73c43",
      "name": "Tool: Verify Main Answer",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.2,
      "position": [
        464,
        -464
      ]
    },
    {
      "parameters": {
        "description": "Validates a student's response to a scaffolding sub-question using semantic understanding. Use this ONLY when you previously asked a scaffolding question and the student is now responding to it. Returns: {correct: bool, partially_correct: bool, reasoning: string}",
        "jsCode": "// Validate Scaffolding - Read from workflow context ($json)\ntry {\n  // Extract data from workflow context (passed by Prepare Agent Context node)\n  const studentResponse = $json.student_message || '';\n  const scaffoldingQuestion = $json.scaffolding_last_question || $json.last_tutor_question || '';\n  const problemContext = $json.current_problem?.text || '';\n  \n  if (!studentResponse) {\n    return JSON.stringify({\n      status: 'error',\n      reasoning: 'Missing student_message in workflow context'\n    });\n  }\n  \n  if (!scaffoldingQuestion) {\n    return JSON.stringify({\n      status: 'error',\n      reasoning: 'Missing scaffolding question in workflow context'\n    });\n  }\n  \n  // Return structured data for agent to evaluate\n  // Agent will use its LLM to determine if response is correct\n  return JSON.stringify({\n    scaffolding_question: scaffoldingQuestion,\n    student_response: studentResponse,\n    problem_context: problemContext,\n    validation_guidelines: {\n      accept_text_numbers: true,\n      semantic_meaning: 'Accept \"minus 2\" = \"-2\" = \"negative 2\"',\n      criteria: 'correct|partially_correct|incorrect'\n    }\n  });\n  \n} catch (error) {\n  return JSON.stringify({ \n    status: 'error',\n    error: error.message, \n    stack: error.stack \n  });\n}"
      },
      "id": "ad005427-7c4b-4dcb-a4d5-09f3552d941a",
      "name": "Tool: Validate Scaffolding",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.2,
      "position": [
        592,
        -464
      ]
    },
    {
      "parameters": {
        "jsCode": "// Build context for AI Agent\nconst inputData = $input.item.json;\nconst sessionData = $('Load Session').item.json;\nconst session = sessionData.session;\n\nconst recentTurns = session.recent_turns || [];\nconst lastTutorMessage = recentTurns.length > 0 ? recentTurns[recentTurns.length - 1]?.tutor_response || '' : '';\nconst lastCategory = recentTurns.length > 0 ? recentTurns[recentTurns.length - 1]?.category : null;\n\n// Check if last turn is from current problem (not previous problem)\nconst lastTurnFromCurrentProblem = recentTurns.length > 0 && \n  !recentTurns[recentTurns.length - 1]?.is_previous_problem;\n\n// Get state from session (preferred) or detect heuristically (fallback)\nconst scaffoldingState = session.current_problem?.scaffolding || { active: false, depth: 0, last_question: null };\nconst teachBackState = session.current_problem?.teach_back || { active: false, awaiting_explanation: false };\n\n// Fallback: Detect if we're in scaffolding mode (if state not set)\nif (!scaffoldingState.active && recentTurns.length > 0) {\n  const hasQuestionMark = lastTutorMessage.includes('?');\n  const isScaffoldingQuestion = lastTurnFromCurrentProblem && hasQuestionMark && (\n    lastTutorMessage.toLowerCase().includes('what does') ||\n    (lastTutorMessage.toLowerCase().includes('what is') && \n      !lastTutorMessage.toLowerCase().includes(session.current_problem.text.toLowerCase())) ||\n    lastTutorMessage.toLowerCase().includes('mean') ||\n    lastTutorMessage.toLowerCase().includes('think about') ||\n    lastTutorMessage.toLowerCase().includes('how') ||\n    lastTutorMessage.toLowerCase().includes('can you tell me') ||\n    lastTutorMessage.toLowerCase().includes('where is') ||\n    lastTutorMessage.toLowerCase().includes('where does') ||\n    lastTutorMessage.toLowerCase().includes('show me') ||\n    lastTutorMessage.toLowerCase().includes('visualize') ||\n    lastTutorMessage.toLowerCase().includes('represent') ||\n    lastTutorMessage.toLowerCase().includes('which direction') ||\n    lastTutorMessage.toLowerCase().includes(\"let's start\")\n  );\n  \n  if (isScaffoldingQuestion) {\n    scaffoldingState.active = true;\n    scaffoldingState.last_question = lastTutorMessage;\n  }\n}\n\n// Fallback: Detect if we're in teach-back mode (if state not set)\nif (!teachBackState.active && lastTurnFromCurrentProblem && lastCategory === 'correct') {\n  const isTeachBackQuestion = (\n    lastTutorMessage.toLowerCase().includes('explain') ||\n    lastTutorMessage.toLowerCase().includes('how did you') ||\n    lastTutorMessage.toLowerCase().includes('walk me through') ||\n    lastTutorMessage.toLowerCase().includes('tell me how')\n  );\n  \n  if (isTeachBackQuestion) {\n    teachBackState.active = true;\n    teachBackState.awaiting_explanation = true;\n  }\n}\n\nreturn [{\n  json: {\n    student_message: inputData.message,\n    current_problem: session.current_problem,\n    attempt_count: session.current_problem?.attempt_count || 1,\n    is_scaffolding_active: scaffoldingState.active,\n    scaffolding_depth: scaffoldingState.depth,\n    scaffolding_last_question: scaffoldingState.last_question || lastTutorMessage,\n    is_teach_back_active: teachBackState.active,\n    teach_back_awaiting: teachBackState.awaiting_explanation,\n    last_tutor_question: scaffoldingState.active ? (scaffoldingState.last_question || lastTutorMessage) : null,\n    last_category: lastCategory,\n    session_id: sessionData._session_id,\n    student_id: sessionData.student_id,\n    _session: session,\n    _start_time: sessionData._start_time\n  }\n}];"
      },
      "id": "d3be5e42-251b-4bd0-9f87-e7f1d5a60c6f",
      "name": "Prepare Agent Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -864,
        -592
      ],
      "notes": "Detects scaffolding mode and builds context for agent"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=The student said: \"{{ $json.student_message }}\"\n\nYou MUST call one of the available tools to validate this response. After calling the tool, return ONLY the required JSON structure with no additional text.",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "=You classify student responses during scaffolding.\n\nContext:\n- Student said: \"{{ $json.student_message }}\"\n- Scaffolding question: \"{{ $json.scaffolding_last_question }}\"\n- Main problem: {{ $json.current_problem.text }}\n- Correct answer: {{ $json.current_problem.correct_answer }}\n\nDETECT INTENT:\nDetermine if the student is answering the MAIN PROBLEM or responding to the SCAFFOLDING QUESTION.\n\nMain problem indicators:\n- Contains phrases like \"the answer is\", \"I think it's\", \"I see\", \"correct answer is\"\n- Standalone numeric answer that matches the main problem's expected answer range\n- Direct answer attempt to the main problem\n\nIf MAIN PROBLEM ATTEMPT:\n1. Call the verify_main_answer tool\n2. Use the tool's returned category (\"correct\", \"close\", or \"wrong_operation\")\n3. Set is_main_problem_attempt: true\n\nIf SCAFFOLDING RESPONSE:\n1. Call the validate_scaffolding tool to get context about what was asked\n2. Carefully evaluate if the student's response answers the scaffolding question:\n\n   EVALUATION RULES:\n   - Parse what the scaffolding question is asking for (quantity, direction, position, concept)\n   - Check if student's answer addresses that specific question\n   - Be FLEXIBLE with answer formats:\n     * Numeric: \"5\", \"five\", \"5 spaces\", \"five spaces\" all mean the same\n     * Directional: \"right\", \"to the right\", \"move right\", \"rightward\" all mean the same\n     * Position: \"-3\", \"negative 3\", \"minus 3\", \"3 left of zero\" all mean the same\n   - Consider the answer CORRECT if it shows understanding of what was asked\n\n   EXAMPLES:\n   Question: \"how many spaces do you need to move to the right?\"\n   - \"5\" \u2192 scaffold_progress \u2713\n   - \"5 spaces\" \u2192 scaffold_progress \u2713 (CORRECT ANSWER)\n   - \"five\" \u2192 scaffold_progress \u2713\n   - \"move 5\" \u2192 scaffold_progress \u2713\n   - \"I don't know\" \u2192 stuck \u2717\n   - \"left\" \u2192 stuck \u2717 (wrong direction)\n\n   Question: \"what is -3?\"\n   - \"negative 3\" \u2192 scaffold_progress \u2713\n   - \"3 spaces to the left of zero\" \u2192 scaffold_progress \u2713\n   - \"minus three\" \u2192 scaffold_progress \u2713\n   - \"3\" \u2192 stuck \u2717 (missing the negative)\n\n3. Classification decision:\n   - If answer clearly addresses the scaffolding question \u2192 category: \"scaffold_progress\"\n   - If \"idk\", \"I don't know\", or genuinely confused \u2192 category: \"stuck\"\n   - If answer is completely wrong or off-topic \u2192 category: \"stuck\"\n   - DEFAULT: If answer shows ANY relevant understanding \u2192 category: \"scaffold_progress\"\n\n4. Set is_main_problem_attempt: false\n\nRETURN FORMAT:\nAfter calling the appropriate tool and evaluating, return this JSON structure:\n{\n  \"category\": \"correct\" | \"close\" | \"wrong_operation\" | \"scaffold_progress\" | \"stuck\",\n  \"is_main_problem_attempt\": boolean,\n  \"confidence\": number between 0 and 1,\n  \"reasoning\": \"brief explanation string\"\n}"
        }
      },
      "id": "6496d3ee-0421-42fa-af62-d7f09b32d11b",
      "name": "AI Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2,
      "position": [
        288,
        -784
      ],
      "notes": "Agent with tools for context-aware classification"
    },
    {
      "parameters": {
        "jsCode": "// Parse agent response with error handling\nconst agentData = $input.item.json;\n\nlet classification;\ntry {\n  // n8n AI Agent with Structured Output Parser returns data in different formats\n  // Try multiple extraction strategies\n  \n  // Strategy 0: Check for __structured__output wrapper (n8n + OpenAI pattern)\n  if (agentData.text && typeof agentData.text === 'string') {\n    try {\n      const parsed = JSON.parse(agentData.text);\n      if (parsed.__structured__output && parsed.__structured__output.category) {\n        classification = parsed.__structured__output;\n      }\n    } catch (e) {\n      // Not JSON or doesn't have __structured__output, try other strategies\n    }\n  }\n  \n  // Strategy 1: Direct object with expected fields (most common)\n  if (!classification && agentData.category && typeof agentData.category === 'string') {\n    classification = {\n      category: agentData.category,\n      is_main_problem_attempt: agentData.is_main_problem_attempt,\n      confidence: agentData.confidence,\n      reasoning: agentData.reasoning\n    };\n  }\n  // Strategy 2: Nested in 'output' field\n  else if (agentData.output) {\n    if (typeof agentData.output === 'string') {\n      classification = JSON.parse(agentData.output);\n    } else if (typeof agentData.output === 'object') {\n      classification = agentData.output;\n    }\n  }\n  // Strategy 3: Nested in 'text' field\n  else if (agentData.text) {\n    if (typeof agentData.text === 'string') {\n      classification = JSON.parse(agentData.text);\n    } else if (typeof agentData.text === 'object') {\n      classification = agentData.text;\n    }\n  }\n  // Strategy 4: Array format\n  else if (Array.isArray(agentData)) {\n    const firstItem = agentData[0];\n    if (firstItem) {\n      if (firstItem.category) {\n        classification = firstItem;\n      } else if (firstItem.output) {\n        classification = typeof firstItem.output === 'string' ? JSON.parse(firstItem.output) : firstItem.output;\n      } else if (firstItem.text) {\n        classification = typeof firstItem.text === 'string' ? JSON.parse(firstItem.text) : firstItem.text;\n      }\n    }\n  }\n  // Strategy 5: message.content format (OpenAI)\n  else if (agentData.message?.content) {\n    if (typeof agentData.message.content === 'string') {\n      classification = JSON.parse(agentData.message.content);\n    } else {\n      classification = agentData.message.content;\n    }\n  }\n\n  if (!classification || !classification.category) {\n    throw new Error('Unable to extract classification with valid category field. Agent data: ' + JSON.stringify(agentData).slice(0, 200));\n  }\n\n} catch (error) {\n  classification = {\n    category: 'stuck',\n    confidence: 0.5,\n    is_main_problem_attempt: false,\n    reasoning: `Parsing error: ${error.message}`,\n    tool_used: 'none',\n    error: true,\n    _raw_data: JSON.stringify(agentData).slice(0, 500)\n  };\n}\n\n// Map teach_back_explanation to stuck for routing (scaffold_progress gets its own response)\nlet responseCategory = classification.category;\nif (classification.category === 'teach_back_explanation') {\n  responseCategory = 'stuck';\n}\n\nreturn [{\n  json: {\n    category: responseCategory,\n    confidence: classification.confidence || 0.5,\n    is_main_problem_attempt: classification.is_main_problem_attempt || false,\n    verification: classification.verification_result || null,\n    agent_reasoning: classification.reasoning || '',\n    tool_used: classification.tool_used || 'none',\n    original_category: classification.category,\n    _parse_error: classification.error || false,\n    _raw_sample: classification._raw_data || null\n  }\n}];"
      },
      "id": "b6fa1084-b51e-44bf-bad0-e2c944749b7c",
      "name": "Parse Agent Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        688,
        -784
      ],
      "notes": "Parses agent JSON, handles errors, maps categories"
    },
    {
      "parameters": {
        "jsCode": "// Build Response Context - Format conversation history for response nodes\nconst classification = $input.item.json;\nconst context = $('Prepare Agent Context').item.json;\nconst session = context._session;\n\n// Format recent turns as chat history string\nlet chatHistory = '';\nif (session.recent_turns && session.recent_turns.length > 0) {\n  chatHistory = session.recent_turns.map((turn, i) => {\n    return `Student: ${turn.student_message}\\nTutor: ${turn.tutor_response}`;\n  }).join('\\n\\n');\n}\n\nreturn [{\n  json: {\n    // Classification data\n    category: classification.category,\n    confidence: classification.confidence,\n    is_main_problem_attempt: classification.is_main_problem_attempt,\n    verification: classification.verification,\n    \n    // Context for response generation\n    current_problem: context.current_problem,\n    message: context.student_message,\n    attempt_count: context.attempt_count,\n    chat_history: chatHistory,\n    is_scaffolding_active: context.is_scaffolding_active,\n    scaffolding_depth: context.scaffolding_depth,\n    is_teach_back_active: context.is_teach_back_active,\n    teach_back_awaiting: context.teach_back_awaiting,\n    \n    // Pass through for later nodes\n    _session: session,\n    _session_id: context.session_id,\n    _start_time: context._start_time,\n    _classification: classification\n  }\n}];"
      },
      "id": "c7a7eb48-794e-4cba-b5dc-271fe7e62c5e",
      "name": "Build Response Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        800,
        -288
      ],
      "notes": "Formats conversation history and merges context for response nodes"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "tutor/message",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "3cc5332f-8b17-4a90-ab3a-37264e4349e2",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [
        -1600,
        -416
      ],
      "webhookId": "tutor-message",
      "notes": "Receives: {student_id, session_id, message, current_problem: {id, text, correct_answer}}"
    },
    {
      "parameters": {
        "jsCode": "// Normalize Input - Transform chat and webhook payloads to consistent format\n  const inputData = $input.item.json;\n\n  // Detect source type\n  let source = 'unknown';\n  let normalizedData = {};\n\n  // Check if this is from Chat Trigger\n  if (inputData.chatId || inputData.chat || inputData.sessionId) {\n    source = 'chat';\n\n    // Map chat fields to expected format\n    normalizedData = {\n      session_id: inputData.chatId || inputData.sessionId || inputData.chat?.id || `chat_${Date.now()}`,\n      student_id: inputData.userId || inputData.user?.id || inputData.from || 'unknown_user',\n      message: inputData.chatInput || inputData.message || inputData.text || inputData.chatMessage || '',\n\n      // Default problem if none provided\n      current_problem: inputData.current_problem || {\n        id: 'default_problem_1',\n        text: 'What is -3 + 5?',\n        correct_answer: '2'\n      },\n\n      // Metadata\n      _source: 'chat',\n      _original_payload: inputData\n    };\n  }\n  // Check if this is from Webhook Trigger\n  else if (inputData.session_id || inputData.student_id || inputData.current_problem) {\n    source = 'webhook';\n\n    // Webhook already in correct format, just pass through\n    normalizedData = {\n      session_id: inputData.session_id,\n      student_id: inputData.student_id,\n      message: inputData.message,\n      current_problem: inputData.current_problem,\n\n      // Metadata\n      _source: 'webhook',\n      _original_payload: inputData\n    };\n  }\n  // Unknown source - try best guess\n  else {\n    source = 'unknown';\n\n    normalizedData = {\n      session_id: inputData.id || `session_${Date.now()}`,\n      student_id: inputData.user || 'unknown',\n      message: inputData.chatInput || inputData.message || inputData.text || '',\n      current_problem: {\n        id: 'default_problem_1',\n        text: 'What is -3 + 5?',\n        correct_answer: '2'\n      },\n\n      // Metadata\n      _source: 'unknown',\n      _original_payload: inputData,\n      _warning: 'Could not detect source type, using defaults'\n    };\n  }\n\n  return {\n    json: normalizedData\n  };"
      },
      "id": "14653bfe-7290-4ddc-9b0a-1523ea615412",
      "name": "Normalize input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1328,
        -592
      ],
      "notes": "Loads session from workflow static data, adds start_time for latency tracking"
    },
    {
      "parameters": {
        "jsCode": "// Load or initialize session from REDIS\n// FIX: Read from Normalize Input, not from Redis node output\nconst normalizedInput = $('Normalize input').first().json;\nconst sessionId = normalizedInput.session_id;\nconst studentId = normalizedInput.student_id;\nconst currentProblem = normalizedInput.current_problem || {\n  id: 'default_problem_1',\n  text: 'What is -3 + 5?',\n  correct_answer: '2'\n};\n\n// Get session from Redis Get node\nlet session = null;\nlet sessionFound = false;\n\ntry {\n  const redisData = $('Redis: Get Session').first().json;\n  // Redis returns {key: '...', value: '...'} or {key: '...', propertyName: '...'}\n  if (redisData && (redisData.value || redisData.propertyName)) {\n    try {\n      session = JSON.parse(redisData.value || redisData.propertyName);\n      sessionFound = true;\n    } catch (error) {\n      session = null;\n    }\n  }\n} catch (error) {\n  // Redis node failed, will create new session\n}\n\nif (!session) {\n  // Create new session\n  session = {\n    session_id: sessionId,\n    student_id: studentId,\n    created_at: new Date().toISOString(),\n    last_active: new Date().toISOString(),\n    current_problem: {\n      id: currentProblem.id,\n      text: currentProblem.text,\n      correct_answer: currentProblem.correct_answer,\n      attempt_count: 0,\n      scaffolding: {\n        active: false,\n        depth: 0,\n        last_question: null\n      },\n      teach_back: {\n        active: false,\n        awaiting_explanation: false\n      }\n    },\n    recent_turns: [],\n    stats: {\n      total_turns: 0,\n      problems_attempted: 1,\n      problems_solved: 0\n    }\n  };\n}\n\n// Check if problem changed (Hybrid Memory: keep only last 3 turns for continuity)\nif (session.current_problem && session.current_problem.id !== currentProblem.id) {\n  // Keep last 3 turns from previous problem for continuity\n  if (session.recent_turns && session.recent_turns.length > 0) {\n    session.recent_turns = session.recent_turns.slice(-3);\n    session.recent_turns.forEach(turn => {\n      turn.is_previous_problem = true;\n    });\n  }\n\n  // Reset problem data\n  session.current_problem = {\n    id: currentProblem.id,\n    text: currentProblem.text,\n    correct_answer: currentProblem.correct_answer,\n    attempt_count: 0,\n    scaffolding: {\n      active: false,\n      depth: 0,\n      last_question: null\n    },\n    teach_back: {\n      active: false,\n      awaiting_explanation: false\n    }\n  };\n  session.stats.problems_attempted++;\n}\n\n// Ensure required fields exist (defensive programming)\nif (!session.recent_turns) {\n  session.recent_turns = [];\n}\nif (!session.current_problem) {\n  session.current_problem = {\n    id: currentProblem.id,\n    text: currentProblem.text,\n    correct_answer: currentProblem.correct_answer,\n    attempt_count: 0,\n    scaffolding: { active: false, depth: 0, last_question: null },\n    teach_back: { active: false, awaiting_explanation: false }\n  };\n} else {\n  // FIX: Even if session.current_problem exists, ensure text and correct_answer are present\n  // This fixes the bug where Redis has incomplete current_problem from previous saves\n  if (!session.current_problem.text || !session.current_problem.correct_answer || !session.current_problem.id) {\n    session.current_problem.id = session.current_problem.id || currentProblem.id;\n    session.current_problem.text = session.current_problem.text || currentProblem.text;\n    session.current_problem.correct_answer = session.current_problem.correct_answer || currentProblem.correct_answer;\n  }\n  // Ensure nested objects exist\n  if (!session.current_problem.scaffolding) {\n    session.current_problem.scaffolding = { active: false, depth: 0, last_question: null };\n  }\n  if (!session.current_problem.teach_back) {\n    session.current_problem.teach_back = { active: false, awaiting_explanation: false };\n  }\n}\n\n// Add start time for latency tracking\nconst startTime = Date.now();\n\nreturn {\n  json: {\n    // FIX: Spread normalizedInput (has message field), not Redis output\n    ...normalizedInput,\n    // Then our explicit fields OVERRIDE\n    session: session,\n    _session_id: sessionId,\n    _start_time: startTime,\n    current_problem: currentProblem\n  }\n};"
      },
      "id": "f1765b16-c4d1-4aa0-aae9-bce6e5aeae2d",
      "name": "Load Session",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1008,
        -592
      ],
      "notes": "Loads session from workflow static data, adds start_time for latency tracking"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "leftValue": "={{$json.category}}",
                    "rightValue": "correct",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "f2730a2d-c83f-4578-b43c-cba4ac33ba5d"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "correct"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "leftValue": "={{$json.category}}",
                    "rightValue": "close",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "7aa208f0-a386-40e6-97e3-e1d9383c9dd7"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "close"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "leftValue": "={{$json.category}}",
                    "rightValue": "wrong_operation",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "03091a63-a69f-491e-b02c-f8414f24cb31"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "wrong_operation"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "leftValue": "={{$json.category}}",
                    "rightValue": "conceptual_question",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "819f2d28-0eff-4133-9353-0ebb60ad8285"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "conceptual_question"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "leftValue": "={{$json.category}}",
                    "rightValue": "stuck",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "a2f03eec-df1f-4283-8b1d-0ec5b9140b1a"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "stuck"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "leftValue": "={{$json.category}}",
                    "rightValue": "off_topic",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "9c82a4d3-7a63-462f-9c50-7b36347e26c6"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "off_topic"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "leftValue": "={{$json.category}}",
                    "rightValue": "scaffold_progress",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "5d7e8f9a-0b1c-2d3e-4f5a-6b7c8d9e0f1a"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "scaffold_progress"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "id": "7f14d2f5-9330-49b9-8d84-2e0de52baafe",
      "name": "Route by Category",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [
        976,
        -624
      ],
      "notes": "6-way router: sends to appropriate response generator"
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "messages": {
          "values": [
            {
              "content": "=You are an encouraging math tutor. The student just gave the CORRECT answer.\n\nProblem: {{$json.current_problem.text}}\nStudent's answer: {{$json.message}} \u2713 CORRECT\n{% if $json.is_scaffolding_active %}Student solved this after working through scaffolding questions.{% endif %}\n\n{{$json.chat_history ? 'Recent conversation:\\n' + $json.chat_history + '\\n' : ''}}\nYour goal: Get them to explain their reasoning (teach-back method - INITIATE teach-back mode).\n\n{% if $json.is_scaffolding_active %}\n{# They solved it after scaffolding - acknowledge the scaffolding helped #}\n- Celebrate that they figured it out with the scaffolding steps\n- Ask them to explain how they put the pieces together to get {{$json.message}}\n- Reference the scaffolding steps they worked through (check chat history)\n{% elif $json.attempt_count === 1 %}\n{# They got it right on the first try #}\n- They got it right on the first try! Ask them to walk you through their thinking.\n{% else %}\n{# They worked through it #}\n- They worked through it and got there! Ask them to explain how they figured it out.\n{% endif %}\n\nCRITICAL GROUNDING RULES:\n- Reference the ACTUAL problem in your teach-back question: {{$json.current_problem.text}}\n- Ask them to explain how they solved THIS specific problem\n- Don't ask generic questions - tie it to the problem they just solved\n{% if $json.is_scaffolding_active %}\n- Acknowledge the scaffolding journey they went through\n{% endif %}\n\nFORMATTING RULE:\n- DO NOT prefix your response with \"Tutor:\", \"Assistant:\", or any label\n- Respond directly as if speaking to the student\n\nRules:\n- Celebrate their success briefly (1-2 words: \"Perfect!\", \"Excellent!\", \"You got it!\")\n- Ask them to explain their reasoning about THIS problem\n- 1-2 sentences total\n- Encouraging, warm tone\n\nYour response:"
            }
          ]
        },
        "options": {
          "maxTokens": 150,
          "temperature": 0.7
        }
      },
      "id": "97492e72-a8c1-45a9-a421-106c1fef200f",
      "name": "Response: Correct",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.4,
      "position": [
        1168,
        -928
      ],
      "credentials": {
        "openAiApi": {
          "id": "IsfTAJGtC8cYJaRq",
          "name": "OpenAi account"
        }
      },
      "notes": "TEACH-BACK: Celebrate + ask for explanation"
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "messages": {
          "values": [
            {
              "content": "=You are a patient math tutor using Socratic questioning.\n\nProblem: {{$json.current_problem.text}}\nStudent's answer: {{$json.message}} (incorrect but close to {{$json.current_problem.correct_answer}})\nThis is attempt #{{$json.attempt_count}}\n\n{{$json.chat_history ? 'Recent conversation:\\n' + $json.chat_history + '\\n' : ''}}\n{{$json.attempt_count === 1 ? 'Give a gentle probing question to help them spot their small error.' : $json.attempt_count === 2 ? 'Give a more explicit hint about where the error is.' : \"They've tried 3+ times. Walk through one step explicitly, then let them finish.\"}}\n\nCRITICAL GROUNDING RULES:\n- Use ONLY the numbers from the original problem: {{$json.current_problem.text}}\n- Point to what's close about THEIR answer ({{$json.message}})\n- DO NOT make up different examples - work with THIS problem\n- If using a number line or visual, use the actual problem's numbers\n- Check conversation history to avoid repeating hints\n\nFORMATTING RULE:\n- DO NOT prefix your response with \"Tutor:\", \"Assistant:\", or any label\n- Respond directly as if speaking to the student\n\nRules:\n- 1-2 sentences maximum\n- Ask, don't tell (unless attempt 3+)\n- Encouraging, patient tone\n- DO NOT give the final answer\n\nYour response:"
            }
          ]
        },
        "options": {
          "maxTokens": 150,
          "temperature": 0.7
        }
      },
      "id": "dd0d9fb2-4e58-46e9-a757-b3d99b72f6cc",
      "name": "Response: Close",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.4,
      "position": [
        1168,
        -752
      ],
      "credentials": {
        "openAiApi": {
          "id": "IsfTAJGtC8cYJaRq",
          "name": "OpenAi account"
        }
      },
      "notes": "PROBE: Gentle questions, escalate to explicit hints on attempt 3+"
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "messages": {
          "values": [
            {
              "content": "=You are a patient math tutor. The student's answer suggests they misunderstood the operation or concept.\n\nProblem: {{$json.current_problem.text}}\nStudent's answer: {{$json.message}} (should be {{$json.current_problem.correct_answer}})\nThis is attempt #{{$json.attempt_count}}\n\n{{$json.chat_history ? 'Recent conversation:\\n' + $json.chat_history + '\\n' : ''}}\n{{$json.attempt_count === 1 ? 'Ask a clarifying question about the operation or concept.' : $json.attempt_count === 2 ? 'Give a more direct hint about the operation or concept.' : \"They've tried 3+ times. Teach the concept directly with an example, then ask them to try.\"}}\n\nCRITICAL GROUNDING RULES:\n- You MUST use the EXACT numbers from the problem: {{$json.current_problem.text}}\n- DO NOT make up easier examples with different numbers (like \"5-2\" or \"8 candies\")\n- Explain THIS specific operation with THESE specific numbers only\n- If using a number line, use the actual problem's numbers\n- Real-world examples must use the same numbers (e.g., \"-3 degrees, then 5 degrees warmer\")\n- Check the conversation history - don't repeat what was already tried\n\nFORMATTING RULE:\n- DO NOT prefix your response with \"Tutor:\", \"Assistant:\", or any label\n- Respond directly as if speaking to the student\n\nRules:\n- Focus on the specific misconception in their answer\n- 2-3 sentences for teaching (attempt 3+), 1 sentence for questions (attempts 1-2)\n- Patient, non-judgmental tone\n- Stay with the ORIGINAL problem\n\nYour response:"
            }
          ]
        },
        "options": {
          "maxTokens": 200,
          "temperature": 0.7
        }
      },
      "id": "3060bed2-f06a-40e0-9120-227b1dddd5f1",
      "name": "Response: Wrong Operation",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.4,
      "position": [
        1168,
        -592
      ],
      "credentials": {
        "openAiApi": {
          "id": "IsfTAJGtC8cYJaRq",
          "name": "OpenAi account"
        }
      },
      "notes": "CLARIFY: Address misconception, teach concept on attempt 3+"
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "messages": {
          "values": [
            {
              "content": "=You are a patient math tutor. The student is asking a conceptual question.\n\nProblem: {{$json.current_problem.text}}\nStudent's question: \"{{$json.message}}\"\n\n{{$json.chat_history ? 'Recent conversation:\\n' + $json.chat_history + '\\n' : ''}}\nYour goal: Teach the concept using simple, concrete examples.\n\nTeaching strategy:\n1. Give a brief, simple definition (1 sentence)\n2. Provide a concrete example using the ACTUAL problem's numbers\n3. Ask a check question to see if they understood\n\nCRITICAL GROUNDING RULES:\n- After explaining the concept, connect it back to: {{$json.current_problem.text}}\n- Use the actual problem numbers in your example whenever possible\n- Your check question must reference the original problem\n- DO NOT use completely different examples - relate to THIS problem\n\nFORMATTING RULE:\n- DO NOT prefix your response with \"Tutor:\", \"Assistant:\", or any label\n- Respond directly as if speaking to the student\n\nRules:\n- Use age-appropriate language\n- 2-3 sentences total\n- End with a check question about the ORIGINAL problem\n- Encouraging tone\n\nYour response:"
            }
          ]
        },
        "options": {
          "maxTokens": 200,
          "temperature": 0.7
        }
      },
      "id": "f3461504-6ebd-4c75-a8a8-80e12a1a584d",
      "name": "Response: Conceptual",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.4,
      "position": [
        1168,
        -432
      ],
      "credentials": {
        "openAiApi": {
          "id": "IsfTAJGtC8cYJaRq",
          "name": "OpenAi account"
        }
      },
      "notes": "CONCEPT: Teach with examples, end with check question"
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "messages": {
          "values": [
            {
              "content": "=You are a patient math tutor.\n\n{% if $json.is_teach_back_active %}\n{# Student is explaining their reasoning after getting the answer correct #}\nProblem: {{$json.current_problem.text}} (they answered correctly)\nStudent's explanation: \"{{$json.message}}\"\n\n{{$json.chat_history ? 'Recent conversation:\\n' + $json.chat_history + '\\n' : ''}}\nYour goal: Acknowledge their explanation warmly and wrap up this problem positively.\n\nFORMATTING RULE:\n- DO NOT prefix your response with \"Tutor:\", \"Assistant:\", or any label\n- Respond directly as if speaking to the student\n\nRules:\n- Acknowledge their explanation (\"I love how you explained that!\", \"Great reasoning!\")\n- Briefly reinforce the key concept if their explanation was solid\n- 1-2 sentences total\n- Celebratory, warm tone\n- Signal completion (\"You've got this!\", \"Ready for the next challenge?\")\n\n{% elif $json.is_scaffolding_active %}\n{# Student answered a scaffolding question incorrectly or is still stuck in scaffolding #}\nProblem: {{$json.current_problem.text}}\nStudent's response to scaffolding: \"{{$json.message}}\"\nThis is attempt #{{$json.attempt_count}}\n\n{{$json.chat_history ? 'Recent conversation:\\n' + $json.chat_history + '\\n' : ''}}\nYour goal: The student didn't get the scaffolding question right. Either:\n1. Re-phrase the same scaffolding question more simply, OR\n2. Break it into an even smaller sub-question\n\nCRITICAL GROUNDING RULES:\n- Stay focused on the MAIN problem: {{$json.current_problem.text}}\n- Use the EXACT numbers from the main problem\n- Check conversation history to see what was already asked\n- Make the scaffolding step smaller and more concrete\n\nFORMATTING RULE:\n- DO NOT prefix your response with \"Tutor:\", \"Assistant:\", or any label\n- Respond directly as if speaking to the student\n\nRules:\n- Acknowledge their effort (\"Good try!\")\n- Give a simpler, more concrete sub-question\n- 1-2 sentences\n- Patient, encouraging tone\n\n{% else %}\n{# Student is stuck or asking for help - initiate scaffolding #}\nProblem: {{$json.current_problem.text}}\nThis is attempt #{{$json.attempt_count}}\n\n{{$json.chat_history ? 'Recent conversation:\\n' + $json.chat_history + '\\n' : ''}}\nYour goal: Break the problem into smaller, manageable steps.\n\n{{$json.attempt_count === 1 ? 'Start with the very first step and ask them to do just that one step.' : $json.attempt_count === 2 ? 'Give them the first step, then ask them to do the second step.' : \"They've tried multiple times. Walk through most of the problem step-by-step, leaving only the final step for them.\"}}\n\nCRITICAL GROUNDING RULES:\n- Break down THIS problem: {{$json.current_problem.text}}\n- Use the EXACT numbers from this problem\n- DO NOT create a simpler problem with different numbers\n- Each scaffolding step must use the actual problem's numbers\n- Check conversation history to see what steps were already tried\n\nFORMATTING RULE:\n- DO NOT prefix your response with \"Tutor:\", \"Assistant:\", or any label\n- Respond directly as if speaking to the student\n\nRules:\n- Break into the smallest possible next step\n- 1-2 sentences\n- Encouraging tone (\"Let's...\", \"We can...\")\n- Ask a specific, focused question about THIS problem\n{% endif %}\n\nYour response:"
            }
          ]
        },
        "options": {
          "maxTokens": 200,
          "temperature": 0.7
        }
      },
      "id": "bcf94608-d54a-4b84-945c-64b31d15dc02",
      "name": "Response: Stuck",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.4,
      "position": [
        1168,
        -256
      ],
      "credentials": {
        "openAiApi": {
          "id": "IsfTAJGtC8cYJaRq",
          "name": "OpenAi account"
        }
      },
      "notes": "SCAFFOLD: Break into tiny steps, more help on attempt 3+"
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "messages": {
          "values": [
            {
              "content": "=You are a friendly but focused math tutor. The student went off-topic.\n\nProblem: {{$json.current_problem.text}}\nStudent said: \"{{$json.message}}\" (unrelated to the problem)\n\nYour goal: Politely redirect them back to the math problem.\n\nFORMATTING RULE:\n- DO NOT prefix your response with \"Tutor:\", \"Assistant:\", or any label\n- Respond directly as if speaking to the student\n\nRules:\n- Acknowledge their input very briefly (1-2 words if appropriate)\n- Gently redirect to the problem\n- 1 sentence total\n- Warm, friendly tone (not scolding)\n- Re-state the problem or ask them to focus\n\nExamples:\n- \"Ha! Let's save that for later. Right now, what do you think the answer is?\"\n- \"I hear you! But first, can you help me with this problem?\"\n- \"Let's focus on the math for now. What's your answer?\"\n\nYour response:"
            }
          ]
        },
        "options": {
          "maxTokens": 100,
          "temperature": 0.7
        }
      },
      "id": "0cd73530-c7bc-4abb-86ae-f47f9fdf7de4",
      "name": "Response: Off-Topic",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.4,
      "position": [
        1168,
        -96
      ],
      "credentials": {
        "openAiApi": {
          "id": "IsfTAJGtC8cYJaRq",
          "name": "OpenAi account"
        }
      },
      "notes": "REDIRECT: Politely refocus on problem"
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "messages": {
          "values": [
            {
              "content": "=You are an encouraging math tutor. The student just answered a scaffolding question correctly!\n\nMain Problem: {{$json.current_problem.text}}\nStudent's response to scaffolding question: \"{{$json.message}}\" \u2713\n\n{{$json.chat_history ? 'Recent conversation:\\n' + $json.chat_history + '\\n' : ''}}\nYour goal: Acknowledge their correct answer and either (1) ask the next scaffolding step, or (2) guide them back to solving the main problem.\n\nSTRATEGY:\n- If this was an early scaffolding step: Acknowledge briefly (\"Great!\", \"Exactly!\") then ask the NEXT step that builds toward the main problem\n- If this was the final scaffolding step: Acknowledge and ask them to now solve the MAIN problem using what they learned\n\nCRITICAL GROUNDING RULES:\n- Stay focused on the MAIN problem: {{$json.current_problem.text}}\n- Use the EXACT numbers from the main problem in your next scaffolding question\n- DO NOT repeat the same scaffolding question - progress to the next step\n- Check conversation history to see what was already asked\n- Each new scaffolding question should be one small step closer to the final answer\n\nFORMATTING RULE:\n- DO NOT prefix your response with \"Tutor:\", \"Assistant:\", or any label\n- Respond directly as if speaking to the student\n\nRules:\n- Briefly acknowledge their correct answer (1-2 words: \"Great!\", \"Exactly!\", \"Perfect!\")\n- Then immediately ask the next step OR guide back to main problem\n- 1-2 sentences total\n- Encouraging, forward-moving tone\n- DO NOT give the final answer to the main problem\n\nYour response:"
            }
          ]
        },
        "options": {
          "maxTokens": 200,
          "temperature": 0.7
        }
      },
      "id": "79eb8ce3-c5bd-4bb6-9678-2e28027d605f",
      "name": "Response: Scaffold Progress",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.4,
      "position": [
        1168,
        64
      ],
      "credentials": {
        "openAiApi": {
          "id": "IsfTAJGtC8cYJaRq",
          "name": "OpenAi account"
        }
      },
      "notes": "SCAFFOLD PROGRESS: Acknowledge correct scaffolding answer, ask next step"
    },
    {
      "parameters": {
        "jsCode": "// Update session with conversation tracking (REDIS)\nconst contextData = $('Build Response Context').item.json;\nconst responseData = $input.item.json;\nconst response = responseData.message?.content || responseData.text || \"I'm here to help you learn!\";\n\nconst session = contextData._session;\nconst classification = contextData._classification;\nconst category = classification.original_category || classification.category;\n\n// Only increment attempt_count for main problem attempts\nif (classification.is_main_problem_attempt) {\n  session.current_problem.attempt_count++;\n}\n\n// STATE TRANSITIONS\n\n// 1. SCAFFOLDING STATE MANAGEMENT\nif (category === 'stuck' && !contextData.is_scaffolding_active && !contextData.is_teach_back_active) {\n  session.current_problem.scaffolding = {\n    active: true,\n    depth: 1,\n    last_question: response\n  };\n} else if (category === 'scaffold_progress') {\n  if (session.current_problem.scaffolding) {\n    session.current_problem.scaffolding.depth++;\n    session.current_problem.scaffolding.last_question = response;\n  }\n} else if (category === 'stuck' && contextData.is_scaffolding_active && !contextData.is_teach_back_active) {\n  // Keep scaffolding active when student is stuck during scaffolding\n  if (session.current_problem.scaffolding) {\n    session.current_problem.scaffolding.last_question = response;\n    // Keep active and depth unchanged\n  }\n} else if (category === 'correct' && contextData.is_scaffolding_active) {\n  session.current_problem.scaffolding = {\n    active: false,\n    depth: 0,\n    last_question: null\n  };\n}\n\n// 2. TEACH-BACK STATE MANAGEMENT\nif (category === 'correct' && !contextData.is_teach_back_active) {\n  session.current_problem.teach_back = {\n    active: true,\n    awaiting_explanation: true\n  };\n} else if (category === 'teach_back_explanation') {\n  session.current_problem.teach_back = {\n    active: false,\n    awaiting_explanation: false\n  };\n}\n\n// Mark solved if correct\nif (classification.category === 'correct') {\n  session.stats.problems_solved++;\n}\n\n// Track conversation in recent_turns\nif (!session.recent_turns) {\n  session.recent_turns = [];\n}\n\nsession.recent_turns.push({\n  student_message: contextData.message,\n  tutor_response: response,\n  category: classification.category,\n  timestamp: new Date().toISOString()\n});\n\n// Keep only last 15 turns\nif (session.recent_turns.length > 15) {\n  session.recent_turns = session.recent_turns.slice(-15);\n}\n\nsession.last_active = new Date().toISOString();\nsession.stats.total_turns++;\n\n\n// Debug info for n8n UI\nconst debugInfo = {\n  state_before: {\n    scaffolding_active: contextData.is_scaffolding_active,\n    teach_back_active: contextData.is_teach_back_active\n  },\n  state_after: {\n    scaffolding_active: session.current_problem.scaffolding.active,\n    teach_back_active: session.current_problem.teach_back.active\n  },\n  classification: {\n    category: classification.category,\n    original_category: classification.original_category,\n    is_main_problem_attempt: classification.is_main_problem_attempt\n  }\n};\n\nreturn [{\n  json: {\n    output: response,\n    _session_id: contextData._session_id,\n    _session_for_redis: session,\n    _debug: debugInfo\n  }\n}];"
      },
      "id": "d7f33fcf-0c16-46a1-ad37-f69fde479a84",
      "name": "Update Session & Format Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1584,
        -624
      ],
      "notes": "Calculates latency, updates session, saves to static data, formats API response"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "id": "6bf4f305-de24-4033-a224-78c22f20d91c",
      "name": "Webhook Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        1920,
        -624
      ],
      "notes": "Returns: {response: string, metadata: {...}}"
    },
    {
      "parameters": {
        "operation": "get",
        "key": "=tutor_session:{{ $json.session_id }}",
        "options": {}
      },
      "id": "20c2fe14-6156-475a-b627-0b249cff036b",
      "name": "Redis: Get Session",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        -1168,
        -592
      ],
      "credentials": {
        "redis": {
          "id": "lbH3dgkjrvaKhWrb",
          "name": "Redis account"
        }
      },
      "notes": "Loads session from Redis (returns null if not exists)"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "=tutor_session:{{ $json._session_id }}",
        "value": "={{ JSON.stringify($json._session_for_redis) }}"
      },
      "id": "5efde936-2f42-4e88-b06e-3303689c691d",
      "name": "Redis: Save Session",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        1712,
        -624
      ],
      "credentials": {
        "redis": {
          "id": "lbH3dgkjrvaKhWrb",
          "name": "Redis account"
        }
      },
      "notes": "Saves session to Redis with 30-min TTL"
    }
  ],
  "pinData": {},
  "connections": {
    "When chat message received": {
      "main": [
        [
          {
            "node": "Normalize input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch: Scaffolding Active?": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Format for Routing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Classification": {
      "main": [
        [
          {
            "node": "Switch: Scaffolding Active?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code: Verify Answer": {
      "main": [
        [
          {
            "node": "Parse Classification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LLM: Extract Intent & Value": {
      "main": [
        [
          {
            "node": "Code: Verify Answer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Agent Context": {
      "main": [
        [
          {
            "node": "LLM: Extract Intent & Value",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Window Buffer Memory": {
      "ai_memory": [
        [
          {
            "node": "AI Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Tool: Validate Scaffolding": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Tool: Verify Main Answer": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Parse Agent Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format for Routing": {
      "main": [
        [
          {
            "node": "Build Response Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Agent Output": {
      "main": [
        [
          {
            "node": "Build Response Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Normalize input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize input": {
      "main": [
        [
          {
            "node": "Redis: Get Session",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Session": {
      "main": [
        [
          {
            "node": "Prepare Agent Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Response Context": {
      "main": [
        [
          {
            "node": "Route by Category",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route by Category": {
      "main": [
        [
          {
            "node": "Response: Correct",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Response: Close",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Response: Wrong Operation",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Response: Conceptual",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Response: Stuck",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Response: Off-Topic",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Response: Scaffold Progress",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Response: Correct": {
      "main": [
        [
          {
            "node": "Update Session & Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Response: Close": {
      "main": [
        [
          {
            "node": "Update Session & Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Response: Wrong Operation": {
      "main": [
        [
          {
            "node": "Update Session & Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Response: Conceptual": {
      "main": [
        [
          {
            "node": "Update Session & Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Response: Stuck": {
      "main": [
        [
          {
            "node": "Update Session & Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Response: Off-Topic": {
      "main": [
        [
          {
            "node": "Update Session & Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Response: Scaffold Progress": {
      "main": [
        [
          {
            "node": "Update Session & Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Redis: Get Session": {
      "main": [
        [
          {
            "node": "Load Session",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Session & Format Response": {
      "main": [
        [
          {
            "node": "Redis: Save Session",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Redis: Save Session": {
      "main": [
        [
          {
            "node": "Webhook Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "cbd5c8fc-d2c4-46f3-b431-ed5642f5d41a",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "15fdefe217dd497a3644ac7579dc52a8d91ba7b8a26ac0fbdc9f2ffe89ed0a93"
  },
  "id": "Ar0sDK9eGPw0IIIM",
  "tags": []
}